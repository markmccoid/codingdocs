# Firebase

[FirebaseDocs](https://firebase.google.com/docs/reference/js/firebase.database.Reference "Firebase Docs")

## Basics

To set up firebase in an application, you will first need to grab the configuration script from the firebase site. Note, this will be different for each Database you use.

```javascript
	 var config = {
	 apiKey: "AIzaSyBAzSz_q2QERnV6LNoJmKjdgexMU",
	 authDomain: "mccoid-todo.firebaseapp.com",
	 databaseURL: "https://mccoid-todo.firebaseio.com",
	 storageBucket: "mccoid-todo.appspot.com",
	 messagingSenderId: "338882228094"
	 };
	 firebase.initializeApp(config);
```

After config, you can get access to the root of your database using:

```javascript
var firebaseRef = firebase.database().ref();
```

The above assumes you have imported firebase into your application and called it "firebase".

You can now use firebaseRef to manipulate your database. 

Your database is made up of nodes and to move around these nodes, you can use the .child() function. Here is a simple DB:

![](./images/DraggedImage.png)

If I wanted to get a reference to the 0 entry above, I would do the following:

```javascript
var fbRef = firebaseRef.child('users/0');   
```

I can now run any command on the fbRef entry (set(), update(), remove(), etc.). I can also get the "key" for that array entry by:

```javascript
consolelog(fbRef.key);
```

Note, that if you create an array by passing an array object, you will get the standard type index (0,1,2,...), if you use the push() command, you will get a firebase style key.

Last thing to remember is that you just about everything you do return a **promise:** 

[Keeping our Promises (and Callbacks)](https://firebase.googleblog.com/2016/01/keeping-our-promises-and-callbacks_76.html)


## Arrays in Firebase

Arrays in firebase are handled by creating unique keys for each item in an array. Each item being an object, i.e. you can have more than one item in this array object.

![](./images/DraggedImage-1.png)

The push() firebase function adds one of these unique keyed objects to the node that you have a reference to. In the code below, we first push on item into the 'notes' node. Note we are saving a reference to this new node and in the next link use the set() function to add data to the new item.

In the next example, I am showing that you can chain the set to the push, however, you will not get a reference back to the new item.

```javascript
var notesRef = firebaseRef.child('notes');

var newNoteRef = notesRef.push();
newNoteRef.set({
		noteText: 'Example Text 1'
});

notesRef.push().set({
		noteText: 'Example Text 2'
});
```

Since push is used so much, you can simplify this by sending the items value as an object passed to push.

```javascript
var newNoteRef = notesRef.push({
		noteText: 'Example Text 1'
});

console.log(newNoteRef.key);
```

Here the newNoteRef is a reference to this new item and one of the properties of this class is the key of the new item. Note that the key is generated by firebase.

# Adding/Updating Data/Deleting
[FirebaseDocs](https://firebase.google.com/docs/reference/js/firebase.database.Reference "Firebase Docs")

## Set

Set will destroy and create. Meaning, if something exists at the node you are setting, it will be removed and then whatever set is creating will be created.

So, you can pass in anything you want, even a structure that is different.  Just know that set is going to removed what was at the ref and replace it with the object you are sending in:

## Update

Update will do exactly what it says, it will update whatever node you have a reference to. You do not have to pass all of the items in the node, just the ones that you want to update.

![](./images/DraggedImage-2.png)

If I want to update the age of the above entry, there are a couple of ways:

```javascript
//update all in one go:
firebaseRef.child('users/0').update({age: 46});

//this way will get reference first:
var updRef = firebaseRef.child('users/0');
updRef.update({age: 46});
```

If you run an update and no item exists to update, it will be created.

## Delete data (Remove)
**remove(onComplete)** returns firebase.Promise containing void

Removes the data at this Database location.

Any data at child locations will also be deleted.

The effect of the remove will be visible immediately and the corresponding event 'value' will be triggered. Synchronization of the remove to the Firebase servers will also be started, and the returned Promise will resolve when complete. If provided, the onComplete callback will be called asynchronously after synchronization has finished.

```javascript
var fbRef = firebase.database().ref('users/ada');
fbRef.remove()
	.then(function() {
		console.log("Remove succeeded.")
	})
	.catch(function(error) {
		console.log("Remove failed: " + error.message)
	});
```

## **Listening for Changes**

You listen for additions to the "array" using the on() function with 'child\_added'

```javascript
var notesRef = firebaseRef.child('notes');

notesRef.on('child_added', (snapshot) => {
	console.log('child added:', snapshot.key, snapshot.val());
});
```

The on() listener can also look for **child\_removed** and **child\_changed** 

## User Management and Authorization

[Manage Users in Firebase | Firebase](https://firebase.google.com/docs/auth/web/manage-users)

## Authentication Rules

These rules define who can see what parts of your data tree.

Here is a basic usage with the assumption that we are authenticating through firebase:

```javascript
{
	"rules": {
		"users": {
			"$uid": {
				".write": "$uid === auth.uid",
				".read": "$uid === auth.uid"
				}
			}  
	}
}
```